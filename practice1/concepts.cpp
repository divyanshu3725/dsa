// FIRST PROGRAM
// #include <iostream>
// int main()
// {
//     std::cout<<"Hello DSA";
//     return 0;
// };

// COMPILATION PROCESS
// we write code in high level language (computer doesn't understand this language)
// compiler takes this HLL code and gives executalbe file (containing low level code) as ouput
// IN DEPTH EXPLANATION
// PREPROCESSING
// it is the first step in the compilation process
// prprocessing is done by the preprocessor
// the preprocessor handles the preprocessor directives
// header files are included
// macros are expanded
// COMPILATION
// it is the second step in the compilation process
// compiler takes the pre-processed code and translates the HLSC into assembly lanuage or an intermediate representation know as assembly code
// this also involves syntax and semantic analysis
// ASSEMBLY
// the assembly code generated by the compiler is converted into machine code by the assembler
// the machine code generated is specific to the target architecture
// OBJECT FILES
// the output by the assembler is an object file which contains machine code
// if our program has multiple source file then multiple object files are generated (because each source file is compile separately)
// LINKING
// The linker combines multiple object files and resolves the references between them
// It produces a final executable file
// If our program uses external libraries, the linker includes the necessary library code in the executable
// There are two types of linking: static linking and dynamic linking
// dynamic linking involves creating reference to the external library function (actual linking is done in the runtime)
// static linking involves including the library code directly into the executable
// LOADING
// the OS's loader loads the executable file into the memory
// the program's code is executed by the CPU

// EXECUTION PROCESS
// we need to include header files before using their functionalities
// iostream header file is necesssary for using the cin and cout functions
// including the "using namespace std" allows us to use cout and cin without std::
// execution of code starts from the main function
// cout is used for printing the output
// << is the insertion operator, it is used with the cout
// >> is the extraction operator, it is used with the cin
// endl is used for inserting new line
// we can use \n inside a string to end the line
// semicolon(;) indicates the end of a statement
// ------------------------------------------------
// CODE for understanding HEADER FILES, NAMESPACE, MAIN FUNCTION, COUT, INSERTION OPERATOR, ENDL, \N, SEMICOLON
// #include <iostream>
// using namespace std;
// int main()
// {
//     cout<<"Namaste\nIndia";
//     return 0;
// };
// ------------------------------------------------

// DATA TYPES
// before storing some data, we need to specify what type of data we are going to store
// declaring data type of a variable gives two information to the compiler (a) what is the type of data that is going to be stored (b) what amount space in the memory will that variable take
// the amount of space that a varaible of a particular type will take is dependent on the compiler
// int takes 4 bytes (in our compiler)
// <sizeof function is used for finding the size of a variable (amount of space that it's taking in the memory)
// ------------------------------------------------
// CODE for understanding DATA TYPES, VARIABLE NAMES, DECLARATIONS, INITIALIZATIONS
// #include <iostream>
// using namespace std;
// int main()
// {
//     int a = 2;
//     cout<<sizeof(a)<<endl;
//     // int is taking 4 bytes
//     // char can store only 1 character
//     char b = 'b';
//     cout<<sizeof(b)<<endl;
//     // char is taking 1 byte
//     bool c = 1;
//     cout<<sizeof(c)<<endl;
//     // bool is taking 1 byte
//     float d = 1.23;
//     cout<<sizeof(d)<<endl;
//     // float is taking 4 bytes
//     double e = 1.1234;
//     cout<<sizeof(e)<<endl;
//     // double is taking 8 bytes
//     return 0;
// };
// ------------------------------------------------
// variable names (a) can contain digits, letters and underscores (b) cannot start with digit (c) cannot be same as the name of keywords

// HOW INT DATA TYPE IS STORED IN MEMORY
// int a = 8;
// int is taking 4 bytes here
// so integer a will be converted into binary
// 8 in binary is 1000
// 8 will take up 4 bits
// but we have 32 bits
// so end 4 bits will be 1000
// the starting 28 bits will be 0

// HOW CHAR DATA TYPE IS STORED IN MEMORY
// char a = 'a';
// our char datatye take 1 byte
// every character corresponds to an ascii value
// ascii value for 'a' is 97
// now this 97 will be stored in memory
// how ?
// 97's binary will be stored in 8 bits of memory

// TYPECASTING
// changing one data type to another
// ------------------------------------------------
// CODE for understanding TYPECASTING
// #include <iostream>
// using namespace std;
// int main()
// {
//     // EXPLICIT TYPCASTING
//     // int a = 97;
//     // cout<<a<<endl;
//     // cout<<char(a)<<endl;
//     // return 0;
//     // EXPLICIT TYPCASTING
//     // char to int
//     // char a = 'a';
//     // cout<<a<<endl;
//     // cout<<int(a)<<endl;
//     // return 0;
//     // IMPLICIT TYPCASTING
//     // int a = 'a';
//     // cout<<a<<endl;
//     // IMPLICIT TYPCASTING
//     // char a = 97;
//     // cout<<a<<endl;
// };
// ------------------------------------------------

// MAX AND MIN FOR UNSGINED INT
// max will be (2^32 - 1)
// min will be 0

// MAX AND MIN FOR UNSIGNED CHAR
// max will be (2^8 - 1)
// min will be 0

// WHAT WILL HAPPEN IF WE TRY TO STORE 123456 IN A CHAR
// char a = 123456;
// the binary of 123456 is 11110001001000000
// but char has been assigned a space of 8 bits
// so the data in the starting 8 bits will stored in our char variable a
// means 01000000 will be stored in char variable a
// this correpsonds to 64
// which correpsondds to character@
// ---------------------------------
// CODE
// #include <iostream>
// using namespace std;
// int main()
// {
//     char a = 123456;
//     cout<<a<<endl;
//     return 0;
// };
// ---------------------------------
// we got a warning:  overflow in implicit constant conversion
// understood!

// HOW ARE NEGATIVE NUMBER STORED IN MEMORY
// int a = -6;
// first: we will ignore -ve sign
// second: get binary of integer (get binary of 6)
// 6 is 110
// third: takes two's compilemtn of integer and store the result in memory
// for taking two's compliment first we take 1's compliment and then we add 1 to it
// 1's compliment of 6 will be 11111111111111111111111111111001
// adding 1 we get:            11111111111111111111111111111010
// now this 11111111111111111111111111111010 will be stored in the memory
// if an integer is +ve then the MSB in memory is +ve
// if an integer is -ve then the MSB in memory is -ve
// 11111111111111111111111111111010 has MSB as -ve

// HOW ARE NEGATIVE NUMBERS PRINTIED
// int a = -6;
// 11111111111111111111111111111010 is storing in memory
// MSB is 1 so we will keep a -ve sign reserved
// we will takes 2's compliment of 11111111111111111111111111111010
// 1's compliment comes out to be  00000000000000000000000000000101
// adding 1 to it we get           00000000000000000000000000000110
// 00000000000000000000000000000110 this corresponds to 6
// we have a -ve sign reserved
// so -6 will be printed

// WHAT PROBLEM DOES 2'S COMPLIMENT SOLVE
// WE COULD HAVE MADE A CONVENTION THAT 0SOMETHING WILL BE +VE AND 1SOMETHING WILL BE -VE
// max would be 2^31-1
// min would be - (2^31 - 1)
// but this will cause 0 to have two representations
// so one representation is getting wasted
// to save this 2's compliment was invented
// since we have save one repersentation
// we will use this representation to store a negative number at the extreme end
// so range would be from - (2^31) to (2^31 - 1)

// SIGNED AND UNSIGNED
// for making unsigned we will do unsigned int a = 23;
// this will increase the range of the int (in +ve region)

// WHAT IF WE TRY TO STORE NEGATIVE VALUE IN UNSIGNED INT
// unsigned int a = -2;
// 2 correpsonds to 00000000000000000000000000000010
// 1's compliment:  11111111111111111111111111111101
// 2's compliment:  11111111111111111111111111111110
// now we will try to print this
// compiler won't take it's 2's compliment because we have said that it's +ve
// it will be directtly interpreted as a positive integer in base 10 (4294967294)
// it will print it without taking 2's compliment
// so it will get huge
// ----------------------------
// CODE
// #include <iostream>
// using namespace std;
// int main()
// {
//     unsigned int a = -2;
//     cout<<a<<endl;
//     return 0;
// };
// ----------------------------
// this will print 4294967294

// OPERATORS
// + - * / % && || ! > < >= <= != ==
// ------------------------------------------------
// CODE for understading the DIVISION OPERATOR
// #include <iostream>
// using namespace std;
// int main()
// {
//     int a = 2.4/2;
//     float b = 2.4/2;
//     cout<<a<<endl;
//     cout<<b<<endl;
//     cout<<2.4/2<<endl;
//     return 0;
// };
// ------------------------------------------------

// GUESS THE OUTPUT (IF ELSE CONDITIONALS)
// #include <iostream>
// using namespace std;
// int main()
// {
//     int a = 2;
//     int b = a+1;
//     if((a=3)==b){
//         cout<<"inside if "<<endl;
//         cout<<a<<endl;
//     }
//     else{
//         cout<<"inside else "<<endl;
//         cout<<a+1<<endl;
//     }
//     return 0;
// };

// QUESTION 1 SUPPLIED CHARACTER UPPERCASE OR LOWERCASE OR DIGIT
// #include <iostream>
// using namespace std;
// int main()
// {
//     char firstChar;
//     cout<<"Enter the character: "<<endl;
//     cin>>firstChar;
//     cout<<int(firstChar)<<endl;
//     if(48<=firstChar && firstChar<=57)
//     {
//         cout<<"digit"<<endl;
//     }
//     else if (65<=firstChar && firstChar<=90)
//     {
//         cout<<"upper case"<<endl;
//     }
//     else if (97<=firstChar && firstChar<=122)
//     {
//         cout<<"lower case"<<endl;
//     }
//     else
//     {
//         cout<<"neither uppercase nor lowercase nor digit"<<endl;
//     };
// };

// QUESTION 2 FIND SUM OF ALL EVEN NUMBERS FROM 1 TO N
// #include <iostream>
// using namespace std;
// int main()
// {
//     int n;
//     cout<<"Enter the value of n: ";
//     cin>>n;
//     int sum = 0;
//     for(int i = 1; i<=n; i++)
//     {
//         if(i%2==0)
//         {
//             sum+=i;
//         };
//     };
//     cout<<sum<<endl;
//     return 0;
// };

// QUESTION 3 PRIME OR NOT
// #include <iostream>
// using namespace std;
// int main()
// {
//     int n;
//     cout << "Enter the value of n: ";
//     cin >> n;
//     if (n <= 0)
//     {
//         cout << "please enter positive number!" << endl;
//     }
//     else if (n == 1)
//     {
//         cout << "neither prime nor composite" << endl;
//     }
//     else
//     {
//         bool prime = true;
//         for (int i = 2; i < n; i++)
//         {
//             if (n % i == 0)
//             {
//                 prime = false;
//                 break;
//             };
//         };
//         if (prime)
//         {
//             cout << "it is prime" << endl;
//         }
//         else
//         {
//             cout << "it is composite" << endl;
//         };
//     };
//     return 0;
// };

// AND
// a = 2 010
// b = 3 011
// a&b = 010 = 2
// #include <iostream>
// using namespace std;
// int main()
// {
//     int a = 2;
//     int b = 3;
//     cout<<(a&b)<<endl;
//     return 0;
// };

// OR
// a = 2 010
// b = 3 011
// a|b = 011 = 3
// #include <iostream>
// using namespace std;
// int main()
// {
//     int a = 2;
//     int b = 3;
//     cout<<(a|b)<<endl;
//     return 0;
// };

// NOT
// int a = ~2;
// 2 is  00000000000000000000000000000010
// ~2 is 11111111111111111111111111111101
// for printing 11111111111111111111111111111101 we will do two's compliment
// 1's compliment 00000000000000000000000000000010
// 2's compliment 00000000000000000000000000000011
// 00000000000000000000000000000011 correpsonds to 3
// -3 will printed because MSB of 11111111111111111111111111111101 is 1
// #include <iostream>
// using namespace std;
// int main()
// {
//     int a = 2;
//     cout<<(~a)<<endl;
//     return 0;
// };

// XOR
// 0 ^ 1 1
// 1 ^ 0 1
// 1 ^ 1 0
// 0 ^ 0 0
// 2 ^ 3
// 2 is 010
// 3 is 011
// 2^3 is 001
// so 2^3 is 1
// #include <iostream>
// using namespace std;
// int main()
// {
//     int a = 2;
//     int b = 3;
//     cout<<(a^b)<<endl;
//     return 0;
// };

// LEFT SHIFT OPERATOR
// 2<<1
// 2 is 010
// 100 is 4
// #include <iostream>
// using namespace std;
// int main()
// {
//     int a = 2;
//     cout<<(a<<1)<<endl;
//     int b = 3;
//     cout<<(b<<2)<<endl;
//     return 0;
// };

// RIGHT SHIFT OPERATOR
// 2>>1
// 2 is 010
// 001 is 1
// #include <iostream>
// using namespace std;
// int main()
// {
//     int a = 2;
//     cout<<(a>>1)<<endl;
//     return 0;
// };

// DOING LEFT SHIFT ON LARGER NUMBERS WILL RETURN -VE NUMBERS

// IF WE DO SHIFTING WITH +VE NUMBER THEN PADDING IS DONE WITH 0

// FOR SHIFTING WITH NEGATIVE NUMBER PADDING IS DEPENDENT ON COMPILER

// POST INCREMENT
// use then increment

// PRE INCREMENT
// increment then use

// POST DECREMENT
// use then decrement

// PRE DECREMENT
// use then decrement

// GUESS THE OUTPUT1
// #include <iostream>
// using namespace std;
// int main()
// {
//     int a = 1;
//     int b = 2;
//     if(a-->0 && ++b>2)
//     {
//         cout<<"stage 1 inside if";
//     }
//     else
//     {
//         cout<<"stage 2 inside else";
//     };
//     cout<<endl;
//     cout<<a<<" "<<b<<endl;
//     return 0;
// };

// GUESS THE OUTPUT2
// #include <iostream>
// using namespace std;
// int main()
// {
//     int a = 1;
//     int b = 2;
//     if(a-->0 || ++b>2)
//     {
//         cout<<"stage 1 inside if";
//     }
//     else
//     {
//         cout<<"stage 2 inside else";
//     };
//     cout<<endl;
//     cout<<a<<" "<<b<<endl;
//     return 0;
// };

// GUESS THE OUTPUT3
// #include <iostream>
// using namespace std;
// int main()
// {
//     int number = 3;
//     cout<<(25*(++number))<<endl;
//     return 0;
// };

// GUESS THE OUTPUT4
// #include <iostream>
// using namespace std;
// int main()
// {
//     int a = 1;
//     int b = a++;
//     int c = ++a;
//     cout<<b<<endl;
//     cout<<c<<endl;
//     return 0;
// };

// SUM FROM 1 TO N
// #include <iostream>
// using namespace std;
// int main()
// {
//     int n;
//     cout<<"Enter the value of n: ";
//     cin>>n;
//     int sum = 0;
//     for(int i = 1; i<=n; i++)
//     {
//         sum+=i;
//     };
//     cout<<sum<<endl;
//     return 0;
// };

// FIBONACCI SERIES
// #include <iostream>
// using namespace std;
// void fibo(int n)
// {
//     if(n<=0)
//     {
//         cout<<"Enter a positive number!"<<endl;
//     }
//     else if (n==1 || n==2)
//     {
//         cout<<1<<endl;
//     }
//     else
//     {
//         int a = 1;
//         int b = 1;
//         for(int i = 3; i<=n; i++)
//         {
//             int temp = a;
//             a = b;
//             b = b+temp;
//         };
//         cout<<b<<endl;
//     };
// };
// int main()
// {
//     int n;
//     cout<<"Enter the value of n: ";
//     cin>>n;
//     for(int i = 1; i<=n; i++)
//     {
//         fibo(i);
//     };
// };

// WHETHER N IS PRINE NUMBER OR NOT
// #include <iostream>
// using namespace std;
// int main()
// {
//     int n;
//     cout<<"Enter the value of n: ";
//     cin>>n;
//     if(n<=0)
//     {
//         cout<<"enter +ve number"<<endl;
//     }
//     else if (n==1)
//     {
//         cout<<"neither prime nor composite"<<endl;
//     }
//     else
//     {
//         for(int i = 2; i<n; i++)
//         {
//             if(n%i==0)
//             {
//                 cout<<"composite"<<endl;
//                 return 0;
//             }
//         };
//         cout<<"prime"<<endl;
//     };
//     return 0;
// };

// GUESS THE OUTPUT 1
// #include <iostream>
// using namespace std;
// int main()
// {
//     for(int i = 0; i<=5; i++)
//     {
//         cout<<i<<" ";
//         i++;
//     };
//     return 0;
// };

// GUESS THE OUTPUT 2
// #include <iostream>
// using namespace std;
// int main()
// {
//     for(int i = 0; i<=5; i--)
//     {
//         cout<<i<<endl;
//         i++;
//     }
//     return 0;
// };

// GUESS THE OUTPUT 3
// #include <iostream>
// using namespace std;
// int main()
// {
//     for(int i = 0; i<=15; i+=2)
//     {
//         cout<<i<<" ";
//         if(i&1)
//         {
//             continue;
//         };
//         i++;
//     };
//     return 0;
// };

// GUESS THE OUTPUT 4
// #include <iostream>
// using namespace std;
// int main()
// {
//     for(int i = 0; i<5; i++)
//     {
//         for(int j = i; j<=5; j++)
//         {
//             cout<<i<<" "<<j<<endl;
//         };
//         cout<<endl;
//     };
//     return 0;
// };

// GUESS THE OUTPUT 5
// #include <iostream>
// using namespace std;
// int main()
// {
//     for(int i = 0; i<5; i++)
//     {
//         for(int j = i; j<=5; j++)
//         {
//             if(i+j==10)
//             {
//                 break;
//             };
//             cout<<i<<" "<<j<<endl;
//         };
//     };
//     return 0;
// };

// DECIMAL TO BINARY
// DIVISION BY 2
// 2 4 0
// 2 2 0
// 2 1 1
//   0
// 2 7 1
// 2 3 1
// 2 1 1
//   0
// 2 2 0
// 2 1 1
//   0
// FIRST WAY (using division by 2 method) (using the pow function)
// #include <iostream>
// #include <algorithm>
// #include <vector>
// #include <cmath>
// using namespace std;
// int binaryOf(int n)
// {
//     float result = 0;
//     int count = 0;
//     while(n!=0)
//     {
//         int remainder = n%2;
//         result += pow(10,count)*remainder;
//         count++;
//         n/=2;
//     };
//     return int(result);
// };
// int main()
// {
//     int n;
//     cout<<"Enter the value of n: ";
//     cin>>n;
//     cout<<binaryOf(n)<<endl;
//     return 0;
// };
// SECOND WAY (using division by 2 method) (without using the pow function)
// #include <iostream>
// #include <algorithm>
// #include <vector>
// #include <cmath>
// using namespace std;
// int binaryOf(int n)
// {
//     int result = 0;
//     int count = 0;
//     while(n!=0)
//     {
//         int remainder = n%2;
//         if(count==0)
//         {
//             result += remainder;
//             count=1;
//         }
//         else
//         {
//             result += 10*count*remainder;
//             count*=10;
//         };
//         n/=2;
//     };
//     return result;
// };
// int main()
// {
//     int n;
//     cout<<"Enter the value of n: ";
//     cin>>n;
//     cout<<binaryOf(n)<<endl;
//     return 0;
// };
// THIRD WAY (using the bit manipulation method) (without using the pow function)
// #include <iostream>
// #include <algorithm>
// #include <vector>
// #include <cmath>
// using namespace std;
// int binaryOf(int n)
// {
//     int result = 0;
//     int count = 0;
//     while(n!=0)
//     {
//         int lastBit = n&1;
//         if(count==0)
//         {
//             result += lastBit;
//             count=1;
//         }
//         else
//         {
//             result += 10*count*lastBit;
//             count*=10;
//         };
//         n>>=1;
//     };
//     return result;
// };
// FOURTH WAY (using the bit manipulation method) (using pow function)
// #include <iostream>
// #include <algorithm>
// #include <vector>
// #include <cmath>
// using namespace std;
// int binaryOf(int n)
// {
//     float result = 0;
//     int count = 0;
//     while(n!=0)
//     {
//         int lastBit = n&1;
//         result += pow(10,count)*lastBit;
//         count++;
//         n>>=1;
//     };
//     return result;
// };
// int main()
// {
//     int n;
//     cout<<"Enter the value of n: ";
//     cin>>n;
//     cout<<binaryOf(n)<<endl;
//     return 0;
// };

// BINARY TO DECIMAL
// #include <iostream>
// #include <algorithm>
// #include <cmath>
// #include <vector>
// using namespace std;
// int decimalOf(int n)
// {
//     float result = 0;
//     int count = 0;
//     while(n!=0)
//     {
//         int lastBit = n%10;
//         result += pow(2,count)*lastBit;
//         count++;
//         n/=10;
//     };
//     return int(result);
// };
// int main()
// {
//     int n;
//     cout<<"Enter the value of n: ";
//     cin>>n;
//     cout<<decimalOf(n)<<endl;
//     return 0;
// };

// TIME COMPLEXITY
// amount of time taken by an algorithm to run as a function of length of input
// why do we need complexities:
// - to compare algorithm
// - for making better programs
// Big O Notation for upper bound worst case scenario
// Theta Notation for middle bound average case scenario
// Omega Notation for lower bound best case scenario
// O(1) for constant time
// O(n) for linear time
// O(logn) for logarithmic time
// O(n^2) for quadratic time
// O(n^3) for cubic time
// O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(N^3) < O(2^n) < O(N!)
// f(n) -> 2(n^2) + 3(n) -> O(n^2)
// f(n) -> 4(n^4) + 3(n^3) -> O(n^4)
// f(n) -> (n^2) + logN -> O(n^2)
// f(n) -> 200 -> O(1)
// f(n) -> 3(n^3) + 2(n^2) + 5 -> O(n^3)
// f(n) -> (n^3)/300 -> O(n^3)
// f(n) -> 5(n^2) + logN -> O(n^2)
// f(n) -> n/4 -> O(n)
// f(n) -> n+4/4 -> O(n)
// time complexity of print array function will be O(n)
// time complexity of reverse array function will be O(n) (actally n/2)
// time complexity of linear search in an array O(n)
// time complexity of the following code
// int a = 0;
// for(i = 0; i<N; i++)
// {
//     for(j = N; j>i; j--)
//     {
//         a = a + i + j;
//     };
// };
// N = 1; 1
// N = 2; 2 1
// N = 3; 3 2 1
// so for N = n; loop will run ((n^2) + n)/2 so TC = O(n^2)
// simple method is to just do calculation for the worst case
// for worst case N = n and i = 0; loop will run (n^2) times
// TC for max in array and min in array will be O(n)
// TC for isPrime function will be O(n) (actually n-2)

// TLE
// Most modern machines can perform 10^8 operations/second
// n < 11 : O(n!) , O(n^6)
// n < 18: O((2^n)*(n^2))
// n < 100 : O(n^4)
// n < 400 : O(n^3)
// n < 2000 : O((n^2)*log(n))
// n < 10^4 : O(n^2)
// n < 10^6 : O(n*log(n))
// n < 10^8 : O(n) , O(logn)

// SPACE COMPLEXITY
// amount of time taken by an algorithm to run as a function of length of input
// example 1
// int a = 0, b = 0;
// for(i = 0; i < N; i++)
// {
//     a = a + rand();
// }
// for(j = 0; j < M; j++)
// {
//     b = b + rand();
// }
// SC is O(1)
// example 2
// int a = 0, b = 0;
// for(i = 0; i < N; i++)
// {
//     for(j = 0; j < N; j++)
//     {
//         a = a + j;
//     }
// }
// for(k = 0; k < N; k++)
// {
//     b = b + k;
// }
// SC is O(1)
// example 3
// int a = 0;
// for(i = 0; i < N; i++)
// {
//     for(j = N; j > i; j--)
//     {
//         a = a + i + j;
//     };
// };
// SC is O(1)
// example 4
// func()
// {
//     int arr[5] = {1,2,3,4,5};
//     // cod with O(1)
// };
// SC is O(1) (because the size has been fixed)
// example 5
// int n;
// cin>>n;
// vector<int> vect[n];
// SC is O(n)
// example 6
// for(0 to n)
// {
//     vector <int> vect[n];
//     for(0 to n)
//     {
//         // code
//     }
// }
// SC is O(n)
// for loop time khaaega
// vector space khaaega
// TC calculate karte wakt vector ke size ko nahi dekhne ka
// SC calculate karte wakt for ke limit ko nahi dekhne ka

// ARRAYS
// arrays in c++ can store only similar type of items
// elements in an array are stored in contagious memory locations
// #include <iostream>
// using namespace std;
// int main()
// {
//     // char arr[5] = {'a','b','c','d','e'};
//     // or
//     // char arr[] = {'a','b','c','d','e'};
//     // cout<<"value at address "<<"arr"<<" ("<<arr<<")"<<" is "<<*(arr)<<endl;
//     // cout<<"value at address "<<"arr+1"<<" ("<<arr+1<<")"<<" is "<<*(arr+1)<<endl;
//     // cout<<"value at address "<<"arr+2"<<" ("<<arr+2<<")"<<" is "<<*(arr+2)<<endl;
//     // cout<<"value at address "<<"arr+3"<<" ("<<arr+3<<")"<<" is "<<*(arr+3)<<endl;
//     // cout<<"value at address "<<"arr+4"<<" ("<<arr+4<<")"<<" is "<<*(arr+4)<<endl;
//     // return 0;
//     char arr[3] = {'a'};
//     cout<<arr[0]<<endl;
//     cout<<arr[1]<<endl;
//     cout<<arr[2]<<endl;
// };

// ARRAY UTILITY FUNCTIONS
// #include <iostream>
// using namespace std;
// void printArray(int arr[], int n)
// {
//     for(int i = 0; i<n; i++)
//     {
//         cout<<arr[i]<<" ";
//     };
//     cout<<endl;
// };
// int maxElement(int arr[], int n)
// {
//     int maxElem = INT32_MIN;
//     for(int i = 0; i<n; i++)
//     {
//         if(arr[i]>maxElem)
//         {
//             maxElem = arr[i];
//         };
//     };
//     return maxElem;
// };
// int minElement(int arr[], int n)
// {
//     int minElem = INT32_MAX;
//     for(int i = 0; i<n; i++)
//     {
//         if(arr[i]<minElem)
//         {
//             minElem = arr[i];
//         };
//     };
//     return minElem;
// };
// void inputArrayElement(int arr[], int n)
// {
//     for(int i = 0; i<n; i++)
//     {
//         cin>>arr[i];
//     }
// };
// int sumOfElements(int arr[], int n)
// {
//     int sum = 0;
//     for(int i = 0; i<n; i++)
//     {
//         sum+=arr[i];
//     };
//     return sum;
// }
// void reverseArray1(int arr[], int n)
// {
//     int limit = n/2;
//     for(int i = 0; i<limit; i++)
//     {
//         int temp = arr[i];
//         arr[i] = arr[n-i-1];
//         arr[n-i-1] = temp;
//     };
// };
// void reverseArray2(int arr[], int n)
// {
//     int start = 0;
//     int end = n-1;
//     while(start!=end)
//     {
//         swap(arr[start],arr[end]);
//         start++;
//         end--;
//     };
// };

// INBUILT FUNCTIONS:
// MIN_ELEMENT and MAX_ELEMENT (belong to the algorithm header file)
// #include <iostream>
// #include <algorithm>
// using namespace std;
// int main()
// {
//     int arr[] = {2,4,1,5,3};
//     int size = sizeof(arr)/sizeof(arr[0]);
//     cout<<*(min_element(arr,arr+size))<<endl;
//     cout<<*(max_element(arr,arr+size))<<endl;
//     return 0;
// };

// MAX and MIN functions
// #include <iostream>
// #include <algorithm>
// using namespace std;
// int main()
// {
//     cout<<max(1,2)<<endl;
//     cout<<min(1,2)<<endl;
// };

// INSIDER INFORMATION ABOUT ARRAYS
// if array has 5 elements, but we have initialized only 3 values, then accessing the 4th of 5th element of an array using cout<<arr[4]<<endl; will print garbage value
// but if we pass this array to the printArray function, then 0s are printed

// WHY DO WE NEED TO PASS SIZE OF ARRAY EXPLICTLY
// because amount of space alloted to an array might be larger than the space used
// while printing the array we need to specify the amount of space used by the array and not the amount of space alloted to the array

// VARIABLES ARE PASSED BY VALUE, BUT ARRAYS ARE PASSED BY REFERENCE

// LINEAR SEARCH
// has TC O(n)
// bool linearSearch(int arr[], int n, int num)
// {
//     for(int i = 0; i<n; i++)
//     {
//         if(arr[i]==num)
//         {
//             return true;
//         };
//     };
//     return false;
// };

// BINARY SEARCH
// for linear search the TC is O(n)
// is applied only on monotoning functions
// #include <iostream>
// using namespace std;
// int binarySearch(int arr[], int size, int key)
// {
//     int start = 0;
//     int end = size-1;
//     while(start<=end)
//     {
//         cout<<"startElem is "<<arr[start]<<endl;
//         cout<<"endElem is "<<arr[end]<<endl;
//         int midInd = start + (end-start)/2;
//         int midElem = arr[midInd];
//         cout<<"midElem is "<<midElem<<endl;
//         if(key<midElem)
//         {
//             end = midInd-1;
//         }
//         else if (key==midElem)
//         {
//             return midInd;
//         }
//         else
//         {
//             start = midInd + 1;
//         };
//     };
//     return -1;
// };
// int main()
// {
//     int arr[] = {1,2,3,4,5,6};
//     int key = 6;
//     int size = sizeof(arr)/sizeof(arr[0]);
//     cout<<binarySearch(arr,size,key)<<endl;
//     return 0;
// };
// why we shouldn't use s+e/2
// because if s = e = 2^31 - 1
// so we need to use s + (e-s)/2
// for binary search TC is logN (base 2)

// SELECTION SORT
// in selection sort we select the smallest element and send them to their original position
// #include <iostream>
// #include <vector>
// #include <algorithm>
// #include <cmath>
// using namespace std;
// void selectionSort(vector<int> vect)
// {
//     for (int i = 0; i < vect.size()-1; i++)
//     {
//         int minInd = i;
//         for (int j = i; j < vect.size(); j++)
//         {
//             if (vect[j] < vect[minInd])
//             {
//                 minInd = j;
//             };
//         };
//         swap(vect[i], vect[minInd]);
//         for (int i = 0; i < vect.size(); i++)
//         {
//             cout << vect[i] << " ";
//         };
//         cout<<endl;
//     };
// };
// int main()
// {
//     // vector<int> vect = {64, 25, 12, 22, 11};
//     vector<int> vect = {1, 7, 9, 2, 3, 0};
//     for (int i = 0; i < vect.size(); i++)
//     {
//         cout << vect[i] << " ";
//     };
//     cout << endl;
//     selectionSort(vect);
//     return 0;
// };
// COMPLIEXITIES OF SELECTION SORT
// space complexity of this is O(1)
// time complexity of this is O(n^2)
// best case and worst case complexities are O(n^2)
// USE CASES
// - use it for sorting arrays and vector of small size

// BUBBLE SORT
// #include <iostream>
// #include <vector>
// #include <algorithm>
// #include <cmath>
// using namespace std;
// void bubbleSort(vector<int> vect)
// {
//     for (int i = 0; i < vect.size() - 1; i++)
//     {
//         bool swapping = false;
//         for (int j = 0; j < vect.size() - 1 - i; j++)
//         {
//             int firstElem = vect[j];
//             int secondElem = vect[j + 1];
//             if (secondElem < firstElem)
//             {
//                 swapping = true;
//                 swap(vect[j], vect[j + 1]);
//             };
//         };
//         for (int k = 0; k < vect.size(); k++)
//         {
//             cout << vect[k] << " ";
//         };
//         cout << endl;
//         if(!swapping)
//         {
//             break;
//         };
//     };
// };
// int main()
// {
//     // vector<int> vect = {10, 1, 7, 6, 14, 9};
//     // vector<int> vect = {5, 4, 3, 2, 1};
//     vector<int> vect = {1,2,3,4,5};
//     for (int i = 0; i < vect.size(); i++)
//     {
//         cout << vect[i] << " ";
//     };
//     cout << endl;
//     bubbleSort(vect);
//     return 0;
// };
// COMPLEXITIES
// code runs: n-1 n-2 n-3 ...1 times = n(n-1)/2
// time complexity is O(n^2)
// space complexity is O(1)
// best case complexity is O(n) discussed belong
// OPTIMIZATIONS
// we will maintina a bool variable through which we will check if some swaps are required or not
// if swaps are not required than means array has been sorted so we would break from the loop
// IF ARRAYS IS ALREADY SORTED
// we will be running n-1 times so O(n) will be the complexity for best case scenario
// USE CASES

// INSERTION SORT
// EXAMPLE
// 11 1 7 4 8 2 10
// 1 11 7 4 8 2 10
// 1 7 11 4 8 2 10
// 1 4 7 11 8 2 10
// 1 4 7 8 11 2 10
// 1 2 4 7 8 11 10
// 1 2 4 7 8 10 11
// #include <iostream>
// #include <vector>
// #include <algorithm>
// #include <cmath>
// using namespace std;
// void insertionSort(vector<int> vect)
// {
//     for(int i = 1; i<vect.size(); i++)
//     {
//         int checkInd = i;
//         for(int j = i-1; j>=0; j--)
//         {
//             // cout<<"i = "<<i<<" j = "<<j<<endl;
//             if(vect[checkInd]<vect[j])
//             {
//                 // cout<<"swap"<<endl;
//                 swap(vect[checkInd],vect[j]);
//                 checkInd = j;
//             }
//             else
//             {
//                 break;
//             };
//         };
//     for (int k = 0; k < vect.size(); k++)
//     {
//         cout << vect[k] << " ";
//     };
//     cout << endl;
//     }
// };
// int main()
// {
//     vector<int> vect = {5, 4, 3, 2, 1};
//     for (int i = 0; i < vect.size(); i++)
//     {
//         cout << vect[i] << " ";
//     };
//     cout << endl;
//     insertionSort(vect);
//     return 0;
// };
// USE CASES
// - it is very adabptable algorithm
// - it is stable algorithm
// - if n is small then this is better algorithm
// COMPLEXITIES
// - code runs: 1 2 3 ..n-1 = (n)(n-1)/2
// - time complexity is O(n^2)
// - space complexity is O(1)
// - best case complexity is O(n) (runs n-1 times)



// RESEARCH TO BE DONE
// about the auto keyword

// PROBLEMS TO BE SORTED OUT
// slow compilation of c++ code

// HOMEWORKS
// TASK (INITIALIZE AN ARRAY OF SIZE N WITH EVERY ELEMENT AS x)
// STABLE AND UNSTABLE ALGORITHMS (FOR BUBBLE AND SELECTION)
// WHAT IS IN-PLACE SORTING